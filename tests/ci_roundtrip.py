#!/usr/bin/env python3
import sys
from collections import Counter
from delimiters import parse, unparse
from telethon import types

SAMPLES = [
    ("inline_basic", "**Bold** __Italic__ !!Underline!! ||Spoiler||"),
    ("url_mention_emoji", "[Google](https://google.com) [User](tg://user?id=93602376) ![ğŸ”¥](emoji/5368324170671202286)"),
    ("blockquote_multi", "%%\nLine one of a long collapsed blockquote.\nLine two with more content.\nLine three continues the explanation.\nLine four adds context and details.\nLine five wraps up the summary and provides closure.\n%%"),
    ("mixed", "**Bold** and __italic__ mixed with [Link](https://openai.com) and [Name](tg://user?id=983266749) and custom emoji ![ğŸ‘](emoji/5368324170671202286)"),
]


def normalize_entity(e, text=None):
    name = type(e).__name__
    # Normalize mention forms
    if name == 'MessageEntityMentionName':
        return 'Mention'
    if name == 'MessageEntityTextUrl':
        # If text url points to tg:// treat as mention
        url = getattr(e, 'url', '')
        if url and url.startswith('tg://'):
            return 'Mention'
        return 'TextUrl'
    if name == 'MessageEntityCustomEmoji':
        return 'CustomEmoji'
    if name == 'MessageEntityBlockquote':
        return 'Blockquote(collapsed)' if getattr(e, 'collapsed', False) else 'Blockquote(expanded)'
    # Map common formatting
    mapping = {
        'MessageEntityBold': 'Bold',
        'MessageEntityItalic': 'Italic',
        'MessageEntityUnderline': 'Underline',
        'MessageEntityStrike': 'Strike',
        'MessageEntitySpoiler': 'Spoiler',
        'MessageEntityCode': 'Code',
        'MessageEntityPre': 'Pre',
        'MessageEntityTextUrl': 'TextUrl',
        'MessageEntityUrl': 'Url',
    }
    return mapping.get(name, name)


def counter_from_entities(ents, text=None):
    return Counter(normalize_entity(e, text) for e in ents or [])


def run_sample(name, sample):
    print(f"Running sample: {name}")
    text, ents = parse(sample, mode='md')
    if text is None:
        print('Parse returned None text')
        return False
    rt = unparse(text, ents, mode='md')
    text2, ents2 = parse(rt, mode='md')

    c1 = counter_from_entities(ents, text)
    c2 = counter_from_entities(ents2, text2)

    # For each entity type in original, ensure parsed round-trip contains at least one of that type
    for k, v in c1.items():
        if c2.get(k, 0) < 1:
            print('FAIL: entity', k, 'missing after roundtrip')
            print('Original entities:', c1)
            print('Roundtrip entities:', c2)
            print('Original text:', repr(text))
            print('Roundtrip md:', repr(rt))
            return False
    print('OK â€” entities preserved (or normalized) ->', c1)
    return True


if __name__ == '__main__':
    failures = []
    for name, sample in SAMPLES:
        ok = run_sample(name, sample)
        if not ok:
            failures.append(name)
    if failures:
        print('FAILED SAMPLES:', failures)
        sys.exit(2)
    print('All round-trip samples passed')
    sys.exit(0)

"""
ğŸ“¦ Delimiters advanced add-ons for Telethon
ğŸ‘¤ Created by Ankit Chaubey | https://github.com/ankit-chaubey/delimiters
Â© 2026 Ankit Chaubey. All rights reserved.
ğŸ“¬ Contact: m.ankitchaubey@gmail.com | Telegram: @ankify @AnkitChaubey @ChaubeyBot
âš ï¸ Warning: Do not edit this file unless you are absolutely sure what you are doing.
ğŸ’¥ Changing this file may break the package.
ğŸš€ Initially built for personal use, now released publicly.
"""
